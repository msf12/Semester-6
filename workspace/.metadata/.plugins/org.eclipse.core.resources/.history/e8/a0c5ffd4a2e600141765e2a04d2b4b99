import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;


public class SegmentedMM {
	
	private final int MEMSIZE;
	private List<Hole> memory;
	
	private class Hole implements Comparable {
		
		private int address, size; //location in memory and size
		private boolean empty; //is there a process here
		
		public Hole(int address, int size)
		{
			this.address = address;
			this.size = size;
			empty = true;
		}
		
		public int compareTo(Object arg0) {
			Hole other = (Hole)arg0;
			if(this.size > other.size)
				return 1;
			else if(this.size < other.size)
				return -1;
			else
				return 0;
		}
			
	}
	
	public SegmentedMM(int memsize)
	{
		MEMSIZE = memsize;
		memory = new ArrayList<Hole>();
		memory.add(new Hole(0,memsize));
	}
	
	public int allocate(int pid, int text_size, int data_size, int heap_size)
	{
		int allocated = -1; //was allocation successful
	
		int[] addresses = new int[]{-1,-1,-1}; //three memory addresses for the process
		int[] chosenHoles = new int[]{-1,-1,-1}; //locations in memory list of the holes
		
		int[] segments = new int[]{text_size,data_size,heap_size};
		
		//the size-sorted order of the segments
		int[] order = new int[3];
		
		//find the correct order such that smallest segment's location in segments[] is order[0]
		if(segments[0] < segments[1])
			order[1]++;
		else
			order[0]++;
		if(segments[1] < segments[2])
			order[2]++;
		else
			order[1]++;
		if(segments[0]<segments[2])
			order[2]++;
		else
			order[0]++;
		
		//find the addresses to allocate at
		for(int i = 0,j = 0;i<memory.size()&&addresses[2]==-1;i++)
		{
			Hole temp = memory.get(i);
			int segmentSize = segments[order[j]];
			if(segmentSize <= temp.size) //is the current Hole's size enough to fit the current segment
			{
				addresses[order[j]] = temp.address;
				chosenHoles[j] = i;
				
				j++; //increment to the next smallest segment
				
				//loop until the remaining space in the current hole can't hold the next segment
				int newsize,newaddress;
				for(newsize = temp.size-segmentSize, newaddress = temp.address+segmentSize; (segmentSize<=newsize)&&(j<3);j++)
				{
					segmentSize = segments[order[j]];
					chosenHoles[j] = i;
					addresses[order[j]] = newaddress;
					newsize -= segmentSize;
					newaddress+= segmentSize;
				}
			}
		}
		
		if(addresses[2] != -1)
		{
			allocated = 1;
		
			for(int i = 0,segmentSize = segments[order[i]]; i < 3; i++,segmentSize = segments[order[i]])
			{
				Hole temp = memory.get(chosenHoles[i]);
				temp.size -= segmentSize;
				temp.address += segmentSize;
			}
			
			table.add(pid, addresses);
		}
		return allocated;
	}

}
