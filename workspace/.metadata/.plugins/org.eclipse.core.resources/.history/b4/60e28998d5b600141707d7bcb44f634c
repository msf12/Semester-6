import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;


public class Scheduler {

	public static void main(String[] args) throws FileNotFoundException {
		if(args.length < 1)
			throw new IllegalArgumentException();
		Scanner scan = new Scanner(new File(args[0]));
		Map<Integer,Integer> jobs = new HashMap<Integer,Integer>();
		Map<Integer,Integer> jobs2 = new HashMap<Integer,Integer>();
		Map<Integer,Integer> jobs3 = new HashMap<Integer,Integer>();
		Map<Integer,Integer> jobs4 = new HashMap<Integer,Integer>();
		while(scan.hasNextLine())
		{
			String[] nextJob = scan.nextLine().split(",");
			if(nextJob[0].charAt(0) == '#')
				continue;
			
			int pid = Integer.parseInt(nextJob[0]);
			int jobTime = Integer.parseInt(nextJob[1]);
			System.out.println(pid + "," + jobTime);
			
			jobs.put(pid, jobTime);
			jobs2.put(pid, jobTime);
			jobs3.put(pid, jobTime);
			jobs4.put(pid, jobTime);
		}
		System.out.println("\nFCFS");
		FCFS(jobs);
		System.out.println("\nRR");
		RR(jobs2);
		System.out.println("\nRR (Time Quantum = 10)");
		RR(jobs3,10);
		System.out.println("\nSJF");
		SJF(jobs4);
		scan.close();
	}
	
	public static void FCFS(Map<Integer,Integer> jobs)
	{
		int totalWaitTime = 0;
		int totalCompletionTime = 0;
		int timeElapsed = 0;
		int minute = 0;
		double jobsPerMinute = 0;
		int jobsCompleted = 0;
		for(int i = 0; i <= jobs.size(); i++)
		{
			if(!jobs.containsKey(i))
				continue;
			int timeToComplete = jobs.get(i);
			totalWaitTime += timeElapsed;
			timeElapsed += timeToComplete;
			totalCompletionTime += timeElapsed;
			if(timeElapsed/60 > minute)
			{
				jobsPerMinute = jobsCompleted/60.0;
				minute = timeElapsed/60;
				jobsCompleted = 0;
			}
//			System.out.println("Job: " + i + 
//					", Turnaround time: " + timeElapsed +
//					", Total time elapsed: " + timeElapsed);
		}
		SchedStats(jobs.size(),totalCompletionTime,totalWaitTime,jobsPerMinute,minute+1);
	}
	
	public static void RR(Map<Integer,Integer> jobs)
	{
		RR(jobs, 1);
	}
	
	public static void RR(Map<Integer,Integer> jobs, int quantum)
	{
		int totalWaitTime = 0;
		int totalCompletionTime = 0;
		int timeElapsed = 0;
		int totalJobs = jobs.size();
		
		final int TIME_QUANTUM = quantum;
		
		while(jobs.size() > 0)
		{
			for(int i = 0; i <= totalJobs; i++)
			{
				if(!jobs.containsKey(i))
					continue;

				int timeToComplete = jobs.get(i);
				if(timeToComplete <= TIME_QUANTUM)
				{
					totalWaitTime += timeElapsed;
					jobs.remove(i);
					timeElapsed += timeToComplete;
					totalCompletionTime += timeElapsed;
				}
				else
				{
					totalWaitTime-=TIME_QUANTUM; //every time a job is run the time that job spends running is not counted
					jobs.put(i, timeToComplete-TIME_QUANTUM);
					timeElapsed += TIME_QUANTUM;
				}
			}
		}
		SchedStats(totalJobs,timeElapsed,totalCompletionTime,totalWaitTime);
	}
	
	public static void SJF(Map<Integer,Integer> j)
	{
		List<Integer> times = new ArrayList<Integer>(j.values());
		Map<Integer,Integer> jobs = new HashMap<Integer,Integer>();
		Collections.sort(times);
		for(int i = 0; i < times.size(); i++)
			jobs.put(i, times.get(i));
		FCFS(jobs);
	}
	
	public static void SchedStats(int nJobs, int tCompletionTime, int tWaitTime, double jobsPerMinute, int minutes)
	{
		double numJobs = nJobs;
		double totalWaitTime = tWaitTime;
		double totalCompletionTime = tCompletionTime;
		System.out.println("Average turnaround: " + totalCompletionTime/numJobs + " seconds/job" + 
				"\nAverage wait time: " + totalWaitTime/numJobs + " seconds" +
				"\nThroughput: " + jobsPerMinute/minutes + " jobs/minute");
	}

}
